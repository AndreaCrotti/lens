!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_NAME	hasktags
%%=	src/Control/Lens/Type.hs	/^(%%=) :: MonadState a m => LensLike ((,) e) a a c d -> (c -> (e, d)) -> m e$/;"	ft	line:242
%%@=	src/Control/Lens/IndexedLens.hs	/^(%%@=) :: MonadState a m => Overloaded (Index i) ((,)e) a a c d -> (i -> c -> (e, d)) -> m e$/;"	ft	line:98
%%@~	src/Control/Lens/IndexedLens.hs	/^(%%@~) :: Overloaded (Index i) f a b c d -> (i -> c -> f d) -> a -> f b$/;"	ft	line:84
%%~	src/Control/Lens/Type.hs	/^(%%~) :: LensLike f a b c d -> (c -> f d) -> a -> f b$/;"	ft	line:224
%=	src/Control/Lens/Setter.hs	/^(%=) :: MonadState a m => Setting a a c d -> (c -> d) -> m ()$/;"	ft	line:508
%@=	src/Control/Lens/IndexedSetter.hs	/^(%@=) :: MonadState a m => Overloaded (Index i) Mutator a a c d -> (i -> c -> d) -> m ()$/;"	ft	line:89
%@~	src/Control/Lens/IndexedSetter.hs	/^(%@~) :: Overloaded (Index i) Mutator a b c d -> (i -> c -> d) -> a -> b$/;"	ft	line:73
%~	src/Control/Lens/Setter.hs	/^(%~) :: Setting a b c d -> (c -> d) -> a -> b$/;"	ft	line:283
&&=	src/Control/Lens/Setter.hs	/^(&&=):: MonadState a m => SimpleSetting a Bool -> Bool -> m ()$/;"	ft	line:615
&&~	src/Control/Lens/Setter.hs	/^(&&~) :: Setting a b Bool Bool -> Bool -> a -> b$/;"	ft	line:461
&=	src/Data/Bits/Lens.hs	/^(&=):: (MonadState a m, Bits b) => Simple Setting a b -> b -> m ()$/;"	ft	line:45
&~	src/Data/Bits/Lens.hs	/^(&~) :: Bits c => Setting a b c c -> c -> a -> b$/;"	ft	line:40
(	src/Control/Lens/IndexedLens.hs	/^(%%@~) = withIndex$/;"	fi	line:85
(	src/Control/Lens/IndexedSetter.hs	/^(%@=) :: MonadState a m => Overloaded (Index i) Mutator a a c d -> (i -> c -> d) -> m ()$/;"	fi	line:89
(	src/Control/Lens/Setter.hs	/^(%~) = adjust$/;"	fi	line:284
(	src/Control/Lens/Type.hs	/^(%%~) = id$/;"	fi	line:225
(	src/Data/Bits/Lens.hs	/^(&=):: (MonadState a m, Bits b) => Simple Setting a b -> b -> m ()$/;"	fi	line:45
**=	src/Control/Lens/Setter.hs	/^(**=) :: (MonadState a m, Floating b) => SimpleSetting a b -> b -> m ()$/;"	ft	line:603
**~	src/Control/Lens/Setter.hs	/^(**~) :: Floating c => Setting a b c c -> c -> a -> b$/;"	ft	line:421
*=	src/Control/Lens/Setter.hs	/^(*=) :: (MonadState a m, Num b) => SimpleSetting a b -> b -> m ()$/;"	ft	line:555
*~	src/Control/Lens/Setter.hs	/^(*~) :: Num c => Setting a b c c -> c -> a -> b$/;"	ft	line:352
+=	src/Control/Lens/Setter.hs	/^(+=) :: (MonadState a m, Num b) => SimpleSetting a b -> b -> m ()$/;"	ft	line:529
+~	src/Control/Lens/Setter.hs	/^(+~) :: Num c => Setting a b c c -> c -> a -> b$/;"	ft	line:336
-=	src/Control/Lens/Setter.hs	/^(-=) :: (MonadState a m, Num b) => SimpleSetting a b -> b -> m ()$/;"	ft	line:541
-~	src/Control/Lens/Setter.hs	/^(-~) :: Num c => Setting a b c c -> c -> a -> b$/;"	ft	line:368
.=	src/Control/Lens/Setter.hs	/^(.=) :: MonadState a m => Setting a a c d -> d -> m ()$/;"	ft	line:496
.>	src/Control/Lens/Indexed.hs	/^(.>)  :: Indexed i k => (b -> c) -> Index i a b -> k a c$/;"	ft	line:67
.~	src/Control/Lens/Setter.hs	/^(.~) :: Setting a b c d -> d -> a -> b$/;"	ft	line:304
//=	src/Control/Lens/Setter.hs	/^(\/\/=) :: (MonadState a m, Fractional b) => SimpleSetting a b -> b -> m ()$/;"	ft	line:567
//~	src/Control/Lens/Setter.hs	/^(\/\/~) :: Fractional c => Setting a b c c -> c -> a -> b$/;"	ft	line:380
<%=	src/Control/Lens/Type.hs	/^(<%=) :: MonadState a m => LensLike ((,)d) a a c d -> (c -> d) -> m d$/;"	ft	line:484
<%@=	src/Control/Lens/IndexedLens.hs	/^(<%@=) :: MonadState a m => Overloaded (Index i) ((,)d) a a c d -> (i -> c -> d) -> m d$/;"	ft	line:117
<%@~	src/Control/Lens/IndexedLens.hs	/^(<%@~) :: Overloaded (Index i) ((,)d) a b c d -> (i -> c -> d) -> a -> (d, b)$/;"	ft	line:62
<%~	src/Control/Lens/Type.hs	/^(<%~) :: LensLike ((,)d) a b c d -> (c -> d) -> a -> (d, b)$/;"	ft	line:403
<&&=	src/Control/Lens/Type.hs	/^(<&&=) :: MonadState a m => SimpleLensLike ((,)Bool) a Bool -> Bool -> m Bool$/;"	ft	line:547
<&&~	src/Control/Lens/Type.hs	/^(<&&~) :: LensLike ((,)Bool) a b Bool Bool -> Bool -> a -> (Bool, b)$/;"	ft	line:466
<**=	src/Control/Lens/Type.hs	/^(<**=) :: (MonadState a m, Floating b) => SimpleLensLike ((,)b) a b -> b -> m b$/;"	ft	line:533
<**~	src/Control/Lens/Type.hs	/^(<**~) :: Floating c => LensLike ((,)c) a b c c -> c -> a -> (c, b)$/;"	ft	line:452
<*=	src/Control/Lens/Type.hs	/^(<*=) :: (MonadState a m, Num b) => SimpleLensLike ((,)b) a b -> b -> m b$/;"	ft	line:505
<*~	src/Control/Lens/Type.hs	/^(<*~) :: Num c => LensLike ((,)c) a b c c -> c -> a -> (c, b)$/;"	ft	line:424
<+=	src/Control/Lens/Type.hs	/^(<+=) :: (MonadState a m, Num b) => SimpleLensLike ((,)b) a b -> b -> m b$/;"	ft	line:491
<+~	src/Control/Lens/Type.hs	/^(<+~) :: Num c => LensLike ((,)c) a b c c -> c -> a -> (c, b)$/;"	ft	line:410
<-=	src/Control/Lens/Type.hs	/^(<-=) :: (MonadState a m, Num b) => SimpleLensLike ((,)b) a b -> b -> m b$/;"	ft	line:498
<-~	src/Control/Lens/Type.hs	/^(<-~) :: Num c => LensLike ((,)c) a b c c -> c -> a -> (c, b)$/;"	ft	line:417
<.	src/Control/Lens/Indexed.hs	/^(<.)  :: Indexed i k => Index i b c -> (a -> b) -> k a c$/;"	ft	line:58
<.=	src/Control/Lens/Setter.hs	/^(<.=) :: MonadState a m => Setting a a c d -> d -> m d$/;"	ft	line:682
<.>	src/Control/Lens/Indexed.hs	/^(<.>) :: Indexed (i, j) k => Index i b c -> Index j a b -> k a c$/;"	ft	line:82
<.~	src/Control/Lens/Setter.hs	/^(<.~) :: Setting a b c d -> d -> a -> (d, b)$/;"	ft	line:320
<//=	src/Control/Lens/Type.hs	/^(<\/\/=) :: (MonadState a m, Fractional b) => SimpleLensLike ((,)b) a b -> b -> m b$/;"	ft	line:512
<//~	src/Control/Lens/Type.hs	/^(<\/\/~) :: Fractional c => LensLike ((,)c) a b c c -> c -> a -> (c, b)$/;"	ft	line:431
<<>=	src/Control/Lens/Type.hs	/^(<<>=) :: (MonadState a m, Monoid r) => SimpleLensLike ((,)r) a r -> r -> m r$/;"	ft	line:554
<<>~	src/Control/Lens/Type.hs	/^(<<>~) :: Monoid m => LensLike ((,)m) a b m m -> m -> a -> (m, b)$/;"	ft	line:473
<>=	src/Control/Lens/Setter.hs	/^(<>=) :: (MonadState a m, Monoid b) => SimpleSetting a b -> b -> m ()$/;"	ft	line:639
<>~	src/Control/Lens/Setter.hs	/^(<>~) :: Monoid c => Setting a b c c -> c -> a -> b$/;"	ft	line:477
<^=	src/Control/Lens/Type.hs	/^(<^=) :: (MonadState a m, Num b, Integral c) => SimpleLensLike ((,)b) a b -> c -> m b$/;"	ft	line:519
<^^=	src/Control/Lens/Type.hs	/^(<^^=) :: (MonadState a m, Fractional b, Integral c) => SimpleLensLike ((,)b) a b -> c -> m b$/;"	ft	line:526
<^^~	src/Control/Lens/Type.hs	/^(<^^~) :: (Fractional c, Integral d) => LensLike ((,)c) a b c c -> d -> a -> (c, b)$/;"	ft	line:445
<^~	src/Control/Lens/Type.hs	/^(<^~) :: (Num c, Integral d) => LensLike ((,)c) a b c c -> d -> a -> (c, b)$/;"	ft	line:438
<||=	src/Control/Lens/Type.hs	/^(<||=) :: MonadState a m => SimpleLensLike ((,)Bool) a Bool -> Bool -> m Bool$/;"	ft	line:540
<||~	src/Control/Lens/Type.hs	/^(<||~) :: LensLike ((,)Bool) a b Bool Bool -> Bool -> a -> (Bool, b)$/;"	ft	line:459
<~	src/Control/Lens/Setter.hs	/^(<~) :: MonadState a m => Setting a a c d -> m d -> m ()$/;"	ft	line:664
Accessor	src/Control/Lens/Getter.hs	/^newtype Accessor r a = Accessor { runAccessor :: r }$/;"	nt	line:138
Acting	src/Control/Lens/Action.hs	/^type Acting m r a c = (c -> Effect m r c) -> a -> Effect m r a$/;"	t	line:104
Action	src/Control/Lens/Action.hs	/^type Action m a c = forall f r. Effective m r f => (c -> f c) -> a -> f a$/;"	t	line:52
AppliedState	src/Control/Lens/Internal.hs	/^newtype AppliedState f a = AppliedState { runAppliedState :: Int -> (f a, Int) }$/;"	nt	line:69
Bool	src/GHC/Generics/Lens.hs	/^  everyr :: Typeable b => Bool -> Simple Traversal (f a) b$/;"	c	line:68
ClassRequired	src/Control/Lens/TH.hs	/^  | ClassRequired$/;"	cons	line:65
Control.Exception.Lens	src/Control/Exception/Lens.hs	/^module Control.Exception.Lens$/;"	m	line:11
Control.Lens	src/Control/Lens.hs	/^module Control.Lens$/;"	m	line:46
Control.Lens.Action	src/Control/Lens/Action.hs	/^module Control.Lens.Action$/;"	m	line:16
Control.Lens.Fold	src/Control/Lens/Fold.hs	/^module Control.Lens.Fold$/;"	m	line:36
Control.Lens.Getter	src/Control/Lens/Getter.hs	/^module Control.Lens.Getter$/;"	m	line:33
Control.Lens.Indexed	src/Control/Lens/Indexed.hs	/^module Control.Lens.Indexed$/;"	m	line:17
Control.Lens.IndexedFold	src/Control/Lens/IndexedFold.hs	/^module Control.Lens.IndexedFold$/;"	m	line:16
Control.Lens.IndexedGetter	src/Control/Lens/IndexedGetter.hs	/^module Control.Lens.IndexedGetter$/;"	m	line:13
Control.Lens.IndexedLens	src/Control/Lens/IndexedLens.hs	/^module Control.Lens.IndexedLens$/;"	m	line:22
Control.Lens.IndexedSetter	src/Control/Lens/IndexedSetter.hs	/^module Control.Lens.IndexedSetter$/;"	m	line:16
Control.Lens.IndexedTraversal	src/Control/Lens/IndexedTraversal.hs	/^module Control.Lens.IndexedTraversal$/;"	m	line:16
Control.Lens.Internal	src/Control/Lens/Internal.hs	/^module Control.Lens.Internal$/;"	m	line:16
Control.Lens.Iso	src/Control/Lens/Iso.hs	/^module Control.Lens.Iso$/;"	m	line:13
Control.Lens.Representable	src/Control/Lens/Representable.hs	/^module Control.Lens.Representable$/;"	m	line:52
Control.Lens.Setter	src/Control/Lens/Setter.hs	/^module Control.Lens.Setter$/;"	m	line:24
Control.Lens.TH	src/Control/Lens/TH.hs	/^module Control.Lens.TH$/;"	m	line:16
Control.Lens.Traversal	src/Control/Lens/Traversal.hs	/^module Control.Lens.Traversal$/;"	m	line:28
Control.Lens.Type	src/Control/Lens/Type.hs	/^module Control.Lens.Type$/;"	m	line:48
Control.Parallel.Strategies.Lens	src/Control/Parallel/Strategies/Lens.hs	/^module Control.Parallel.Strategies.Lens$/;"	m	line:14
Control.Seq.Lens	src/Control/Seq/Lens.hs	/^module Control.Seq.Lens$/;"	m	line:12
CreateClass	src/Control/Lens/TH.hs	/^  | CreateClass$/;"	cons	line:63
CreateInstance	src/Control/Lens/TH.hs	/^  | CreateInstance$/;"	cons	line:64
Data.Array.Lens	src/Data/Array/Lens.hs	/^module Data.Array.Lens$/;"	m	line:14
Data.Bits.Lens	src/Data/Bits/Lens.hs	/^module Data.Bits.Lens$/;"	m	line:13
Data.ByteString.Lazy.Lens	src/Data/ByteString/Lazy/Lens.hs	/^module Data.ByteString.Lazy.Lens$/;"	m	line:13
Data.ByteString.Lens	src/Data/ByteString/Lens.hs	/^module Data.ByteString.Lens$/;"	m	line:12
Data.Complex.Lens	src/Data/Complex/Lens.hs	/^module Data.Complex.Lens$/;"	m	line:12
Data.Dynamic.Lens	src/Data/Dynamic/Lens.hs	/^module Data.Dynamic.Lens$/;"	m	line:11
Data.Either.Lens	src/Data/Either/Lens.hs	/^module Data.Either.Lens$/;"	m	line:13
Data.IntMap.Lens	src/Data/IntMap/Lens.hs	/^module Data.IntMap.Lens$/;"	m	line:15
Data.IntSet.Lens	src/Data/IntSet/Lens.hs	/^module Data.IntSet.Lens$/;"	m	line:11
Data.List.Lens	src/Data/List/Lens.hs	/^module Data.List.Lens$/;"	m	line:17
Data.Map.Lens	src/Data/Map/Lens.hs	/^module Data.Map.Lens$/;"	m	line:14
Data.Pair.Lens	src/Data/Pair/Lens.hs	/^module Data.Pair.Lens$/;"	m	line:15
Data.Sequence.Lens	src/Data/Sequence/Lens.hs	/^module Data.Sequence.Lens$/;"	m	line:12
Data.Set.Lens	src/Data/Set/Lens.hs	/^module Data.Set.Lens$/;"	m	line:11
Data.Text.Lazy.Lens	src/Data/Text/Lazy/Lens.hs	/^module Data.Text.Lazy.Lens$/;"	m	line:11
Data.Text.Lens	src/Data/Text/Lens.hs	/^module Data.Text.Lens$/;"	m	line:12
Data.Tree.Lens	src/Data/Tree/Lens.hs	/^module Data.Tree.Lens$/;"	m	line:13
Effect	src/Control/Lens/Action.hs	/^newtype Effect m r a = Effect { getEffect :: m r }$/;"	nt	line:82
ElementOf	src/Control/Lens/Internal.hs	/^newtype ElementOf f a = ElementOf { getElementOf :: Int -> ElementOfResult f a }$/;"	nt	line:136
ElementOfResult	src/Control/Lens/Internal.hs	/^data ElementOfResult f a$/;"	d	line:125
Field1	src/Control/Lens/Type.hs	/^class Field1 a b c d | a -> c, b -> d, a d -> b, b c -> a where$/;"	c	line:559
Field2	src/Control/Lens/Type.hs	/^class Field2 a b c d | a -> c, b -> d, a d -> b, b c -> a where$/;"	c	line:616
Field3	src/Control/Lens/Type.hs	/^class Field3 a b c d | a -> c, b -> d, a d -> b, b c -> a where$/;"	c	line:663
Field4	src/Control/Lens/Type.hs	/^class Field4 a b c d | a -> c, b -> d, a d -> b, b c -> a where$/;"	c	line:696
Field5	src/Control/Lens/Type.hs	/^class Field5 a b c d | a -> c, b -> d, a d -> b, b c -> a where$/;"	c	line:725
Field6	src/Control/Lens/Type.hs	/^class Field6 a b c d | a -> c, b -> d, a d -> b, b c -> a where$/;"	c	line:750
Field7	src/Control/Lens/Type.hs	/^class Field7 a b c d | a -> c, b -> d, a d -> b, b c -> a where$/;"	c	line:771
Field8	src/Control/Lens/Type.hs	/^class Field8 a b c d | a -> c, b -> d, a d -> b, b c -> a where$/;"	c	line:788
Field9	src/Control/Lens/Type.hs	/^class Field9 a b c d | a -> c, b -> d, a d -> b, b c -> a where$/;"	c	line:801
FieldDesc	src/Control/Lens/TH.hs	/^data FieldDesc = FieldDesc$/;"	d	line:236
Focusing	src/Control/Lens/Internal.hs	/^newtype Focusing m c a = Focusing { unfocusing :: m (c, a) }$/;"	nt	line:44
Fold	src/Control/Lens/Fold.hs	/^type Fold a c = forall f. (Gettable f, Applicative f) => (c -> f c) -> a -> f a$/;"	t	line:104
Found	src/Control/Lens/Internal.hs	/^  | Found {-# UNPACK #-} !Int (f a)$/;"	cons	line:127
GA	src/Control/Lens/Fold.hs	/^newtype GA f a = GA { getGA :: f a }$/;"	nt	line:118
GHC.Generics.Lens	src/GHC/Generics/Lens.hs	/^module GHC.Generics.Lens$/;"	m	line:25
Gettable	src/Control/Lens/Getter.hs	/^class Functor f => Gettable f where$/;"	c	line:112
Getter	src/Control/Lens/Getter.hs	/^type Getter a c = forall f. Gettable f => (c -> f c) -> a -> f a$/;"	t	line:74
Getting	src/Control/Lens/Getter.hs	/^type Getting r a c = (c -> Accessor r c) -> a -> Accessor r a$/;"	t	line:97
HandleSingletons	src/Control/Lens/TH.hs	/^  | HandleSingletons$/;"	cons	line:61
HasName	src/Language/Haskell/TH/Lens.hs	/^class HasName t where$/;"	c	line:39
HasTypeVars	src/Language/Haskell/TH/Lens.hs	/^class HasTypeVars t where$/;"	c	line:57
Index	src/Control/Lens/Indexed.hs	/^newtype Index i a b = Index { withIndex :: (i -> a) -> b }$/;"	nt	line:47
Index	src/Control/Lens/Indexed.hs	/^Index ibc <. ab = index $ \\ia -> ibc (ab . ia)$/;"	fi	line:59
Indexable	src/Control/Lens/Indexed.hs	/^type Indexable i a b = forall k. Indexed i k => k a b$/;"	t	line:39
Indexed	src/Control/Lens/Indexed.hs	/^class Indexed i k where$/;"	c	line:33
IndexedFold	src/Control/Lens/IndexedFold.hs	/^type IndexedFold i a c = forall k f. (Indexed i k, Applicative f, Gettable f) => k (c -> f c) (a -> f a)$/;"	t	line:58
IndexedGetter	src/Control/Lens/IndexedGetter.hs	/^type IndexedGetter i a c = forall k f. (Indexed i k, Gettable f) => k (c -> f c) (a -> f a)$/;"	t	line:28
IndexedGetting	src/Control/Lens/IndexedGetter.hs	/^type IndexedGetting i m a c = Index i (c -> Accessor m c) (a -> Accessor m a)$/;"	t	line:31
IndexedLens	src/Control/Lens/IndexedLens.hs	/^type IndexedLens i a b c d = forall f k. (Indexed i k, Functor f) => k (c -> f d) (a -> f b)$/;"	t	line:43
IndexedSetter	src/Control/Lens/IndexedSetter.hs	/^type IndexedSetter i a b c d = forall f k. (Indexed i k, Settable f) => k (c -> f d) (a -> f b)$/;"	t	line:38
IndexedStore	src/Control/Lens/Internal.hs	/^data IndexedStore c d a = IndexedStore (d -> a) c$/;"	d	line:61
IndexedTraversal	src/Control/Lens/IndexedTraversal.hs	/^type IndexedTraversal i a b c d = forall f k. (Indexed i k, Applicative f) => k (c -> f d) (a -> f b)$/;"	t	line:46
Iso	src/Control/Lens/Iso.hs	/^type Iso a b c d = forall k f. (Isomorphic k, Functor f) => k (c -> f d) (a -> f b)$/;"	t	line:121
Isomorphic	src/Control/Lens/Iso.hs	/^class Category k => Isomorphic k where$/;"	c	line:46
Isomorphism	src/Control/Lens/Iso.hs	/^data Isomorphism a b = Isomorphism (a -> b) (b -> a)$/;"	d	line:67
Language.Haskell.TH.Lens	src/Language/Haskell/TH/Lens.hs	/^module Language.Haskell.TH.Lens$/;"	m	line:17
Lens	src/Control/Lens/Type.hs	/^type Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b$/;"	t	line:151
LensFlag	src/Control/Lens/TH.hs	/^data LensFlag$/;"	d	line:57
LensLike	src/Control/Lens/Type.hs	/^type LensLike f a b c d = (c -> f d) -> a -> f b$/;"	t	line:194
LensLike	src/Control/Lens/Type.hs	/^  focus_ :: Monad m => LensLike (Focusing m ()) a a b b -> st b m c -> st a m ()$/;"	c	line:278
LensRules	src/Control/Lens/TH.hs	/^data LensRules = LensRules$/;"	d	line:101
Max	src/Control/Lens/Internal.hs	/^data Max a = NoMax | Max a$/;"	d	line:111
Min	src/Control/Lens/Internal.hs	/^data Min a = NoMin | Min a$/;"	d	line:97
MonadicFold	src/Control/Lens/Action.hs	/^type MonadicFold m a c = forall f r. (Effective m r f, Applicative f) => (c -> f c) -> a -> f a$/;"	t	line:59
Mutator	src/Control/Lens/Setter.hs	/^newtype Mutator a = Mutator { runMutator :: a }$/;"	nt	line:145
NoMax	src/Control/Lens/Internal.hs	/^data Max a = NoMax | Max a$/;"	d	line:111
NoMin	src/Control/Lens/Internal.hs	/^data Min a = NoMin | Min a$/;"	d	line:97
NotFound	src/Control/Lens/Internal.hs	/^  | NotFound String$/;"	cons	line:128
Overloaded	src/Control/Lens/Type.hs	/^type Overloaded k f a b c d = k (c -> f d) (a -> f b)$/;"	t	line:391
Path	src/Control/Lens/Representable.hs	/^newtype Path f = Path { walk :: Rep f }$/;"	nt	line:211
Rep	src/Control/Lens/Representable.hs	/^type Rep f = forall a. Simple Lens (f a) a$/;"	t	line:90
Representable	src/Control/Lens/Representable.hs	/^class Functor f => Representable f where$/;"	c	line:108
Searching	src/Control/Lens/Internal.hs	/^  = Searching {-# UNPACK #-} !Int a$/;"	d	line:126
Sequenced	src/Control/Lens/Internal.hs	/^newtype Sequenced m = Sequenced { getSequenced :: m () }$/;"	nt	line:90
Settable	src/Control/Lens/Setter.hs	/^class Applicative f => Settable f where$/;"	c	line:124
Setter	src/Control/Lens/Setter.hs	/^type Setter a b c d = forall f. Settable f => (c -> f d) -> a -> f b$/;"	t	line:89
Setting	src/Control/Lens/Setter.hs	/^type Setting a b c d = (c -> Mutator d) -> a -> Mutator b$/;"	t	line:98
Simple	src/Control/Lens/Type.hs	/^type Simple f a b = f a a b b$/;"	t	line:163
SimpleIndexedLens	src/Control/Lens/IndexedLens.hs	/^type SimpleIndexedLens i a b = IndexedLens i a a b b$/;"	t	line:46
SimpleIndexedSetter	src/Control/Lens/IndexedSetter.hs	/^type SimpleIndexedSetter i a b = IndexedSetter i a a b b$/;"	t	line:42
SimpleIndexedTraversal	src/Control/Lens/IndexedTraversal.hs	/^type SimpleIndexedTraversal i a b = IndexedTraversal i a a b b$/;"	t	line:49
SimpleIso	src/Control/Lens/Iso.hs	/^type SimpleIso a b = Iso a a b b$/;"	t	line:125
SimpleLens	src/Control/Lens/Type.hs	/^type SimpleLens a b = Lens a a b b$/;"	t	line:166
SimpleLensLike	src/Control/Lens/Type.hs	/^type SimpleLensLike f a b = LensLike f a a b b$/;"	t	line:169
SimpleLenses	src/Control/Lens/TH.hs	/^  = SimpleLenses$/;"	d	line:58
SimpleOverloaded	src/Control/Lens/Type.hs	/^type SimpleOverloaded k f a b = Overloaded k f a a b b$/;"	t	line:394
SimpleSetter	src/Control/Lens/Setter.hs	/^type SimpleSetter a b = Setter a a b b$/;"	t	line:109
SimpleSetting	src/Control/Lens/Setter.hs	/^type SimpleSetting a b = Setting a a b b$/;"	t	line:117
SimpleTraversal	src/Control/Lens/Traversal.hs	/^type SimpleTraversal a b = Traversal a a b b$/;"	t	line:96
SingletonAndField	src/Control/Lens/TH.hs	/^  | SingletonAndField$/;"	cons	line:59
SingletonIso	src/Control/Lens/TH.hs	/^  | SingletonIso$/;"	cons	line:60
SingletonRequired	src/Control/Lens/TH.hs	/^  | SingletonRequired$/;"	cons	line:62
SubstType	src/Language/Haskell/TH/Lens.hs	/^class SubstType t where$/;"	c	line:97
Traversal	src/Control/Lens/Traversal.hs	/^type Traversal a b c d = forall f. Applicative f => (c -> f d) -> a -> f b$/;"	t	line:93
Traversed	src/Control/Lens/Internal.hs	/^newtype Traversed f = Traversed { getTraversed :: f () }$/;"	nt	line:83
^!	src/Control/Lens/Action.hs	/^(^!) :: Monad m => a -> Acting m c a c -> m c$/;"	ft	line:122
^$	src/Control/Lens/Getter.hs	/^(^$) :: Getting c a c -> a -> c$/;"	ft	line:212
^.	src/Control/Lens/Getter.hs	/^(^.) :: a -> Getting c a c -> c$/;"	ft	line:235
^=	src/Control/Lens/Setter.hs	/^(^=) :: (MonadState a m, Fractional b, Integral c) => SimpleSetting a b -> c -> m ()$/;"	ft	line:579
^^=	src/Control/Lens/Setter.hs	/^(^^=) :: (MonadState a m, Fractional b, Integral c) => SimpleSetting a b -> c -> m ()$/;"	ft	line:591
^^~	src/Control/Lens/Setter.hs	/^(^^~) :: (Fractional c, Integral e) => Setting a b c c -> e -> a -> b$/;"	ft	line:405
^~	src/Control/Lens/Setter.hs	/^(^~) :: (Num c, Integral e) => Setting a b c c -> e -> a -> b$/;"	ft	line:388
_1	src/Control/Lens/Type.hs	/^_1 :: Lens (a,c) (b,c) a b$/;"	ft	line:324
_1	src/Control/Lens/Type.hs	/^  _1 :: Lens a b c d$/;"	ft	line:581
_2	src/Control/Lens/Type.hs	/^_2 :: Lens (c,a) (c,b) a b$/;"	ft	line:337
_2	src/Control/Lens/Type.hs	/^  _2 :: Lens a b c d$/;"	ft	line:628
_3	src/Control/Lens/Type.hs	/^  _3 :: Lens a b c d$/;"	ft	line:665
_4	src/Control/Lens/Type.hs	/^  _4 :: Lens a b c d$/;"	ft	line:698
_5	src/Control/Lens/Type.hs	/^  _5 :: Lens a b c d$/;"	ft	line:727
_6	src/Control/Lens/Type.hs	/^  _6 :: Lens a b c d$/;"	ft	line:752
_7	src/Control/Lens/Type.hs	/^  _7 :: Lens a b c d$/;"	ft	line:773
_8	src/Control/Lens/Type.hs	/^  _8 :: Lens a b c d$/;"	ft	line:790
_9	src/Control/Lens/Type.hs	/^  _9 :: Lens a b c d$/;"	ft	line:803
_const	src/Control/Lens/Iso.hs	/^_const :: Iso a b (Const a c) (Const b d)$/;"	ft	line:182
_fieldName	src/Control/Lens/TH.hs	/^  { _fieldName                   :: Name$/;"	c_a	line:237
_fieldType	src/Control/Lens/TH.hs	/^  , _fieldType                   :: Type$/;"	c_a	line:238
_fieldTypeVarsBoundElsewhere	src/Control/Lens/TH.hs	/^  , _fieldTypeVarsBoundElsewhere :: Set Name$/;"	c_a	line:239
_head	src/Data/List/Lens.hs	/^_head :: Simple Lens [a] a$/;"	ft	line:40
_init	src/Data/List/Lens.hs	/^_init :: Simple Lens [a] [a]$/;"	ft	line:68
_last	src/Data/List/Lens.hs	/^_last :: Simple Lens [a] a$/;"	ft	line:58
_lensClass	src/Control/Lens/TH.hs	/^  , _lensClass :: String -> Maybe (String, String)$/;"	c_a	line:104
_lensField	src/Control/Lens/TH.hs	/^  , _lensField :: String -> Maybe String$/;"	c_a	line:103
_lensFlags	src/Control/Lens/TH.hs	/^  , _lensFlags :: Set LensFlag$/;"	c_a	line:105
_lensIso	src/Control/Lens/TH.hs	/^  { _lensIso   :: String -> Maybe String$/;"	c_a	line:102
_tail	src/Data/List/Lens.hs	/^_tail :: Simple Lens [a] [a]$/;"	ft	line:49
a	src/Control/Lens/Action.hs	/^a ^! l = getEffect (l (Effect . return) a)$/;"	fi	line:123
a	src/Control/Lens/Fold.hs	/^type Fold a c = forall f. (Gettable f, Applicative f) => (c -> f c) -> a -> f a$/;"	fi	line:104
a	src/Control/Lens/Getter.hs	/^type Getter a c = forall f. Gettable f => (c -> f c) -> a -> f a$/;"	fi	line:74
a	src/Control/Lens/Iso.hs	/^type Iso a b c d = forall k f. (Isomorphic k, Functor f) => k (c -> f d) (a -> f b)$/;"	fi	line:121
a	src/Control/Lens/Setter.hs	/^type Setter a b c d = forall f. Settable f => (c -> f d) -> a -> f b$/;"	fi	line:89
a	src/Control/Lens/Traversal.hs	/^type Traversal a b c d = forall f. Applicative f => (c -> f d) -> a -> f b$/;"	fi	line:93
a	src/Control/Lens/Type.hs	/^type Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b$/;"	fi	line:151
act	src/Control/Lens/Action.hs	/^act :: Monad m => (a -> m c) -> Action m a c$/;"	ft	line:127
acts	src/Control/Lens/Action.hs	/^acts :: Action m (m a) a$/;"	ft	line:139
adjust	src/Control/Lens/Setter.hs	/^adjust :: Setting a b c d -> (c -> d) -> a -> b$/;"	ft	line:213
after	src/Control/Parallel/Strategies/Lens.hs	/^after :: Strategy a -> LensLike f a b c d -> LensLike f a b c d$/;"	ft	line:59
allOf	src/Control/Lens/Fold.hs	/^allOf :: Getting All a c -> (c -> Bool) -> a -> Bool$/;"	ft	line:349
andOf	src/Control/Lens/Fold.hs	/^andOf :: Getting All a Bool -> a -> Bool$/;"	ft	line:307
anyOf	src/Control/Lens/Fold.hs	/^anyOf :: Getting Any a c -> (c -> Bool) -> a -> Bool$/;"	ft	line:335
apRep	src/Control/Lens/Representable.hs	/^apRep :: Representable f => f (a -> b) -> f a -> f b$/;"	ft	line:169
appArgs	src/Control/Lens/TH.hs	/^appArgs :: Type -> [TyVarBndr] -> Type$/;"	ft	line:171
apps	src/Control/Lens/TH.hs	/^apps :: Type -> [Type] -> Type$/;"	ft	line:175
appsT	src/Control/Lens/TH.hs	/^appsT :: TypeQ -> [TypeQ] -> TypeQ$/;"	ft	line:178
asumOf	src/Control/Lens/Fold.hs	/^asumOf :: Alternative f => Getting (Endo (f c)) a (f c) -> a -> f c$/;"	ft	line:495
at	src/Data/IntMap/Lens.hs	/^at :: Int -> SimpleIndexedLens Int (IntMap v) (Maybe v)$/;"	ft	line:37
at	src/Data/Map/Lens.hs	/^at :: Ord k => k -> SimpleIndexedLens k (Map k v) (Maybe v)$/;"	ft	line:41
at	src/Data/Sequence/Lens.hs	/^at :: Int -> SimpleIndexedLens Int (Seq a) a$/;"	ft	line:30
backwards	src/Control/Lens/Fold.hs	/^backwards :: LensLike (Backwards f) a b c d -> LensLike f a b c d$/;"	ft	line:184
bc	src/Control/Lens/Indexed.hs	/^bc .> Index iab = index (bc . iab)$/;"	fi	line:68
bindRep	src/Control/Lens/Representable.hs	/^bindRep :: Representable f => f a -> (a -> f b) -> f b$/;"	ft	line:185
bitAt	src/Data/Bits/Lens.hs	/^bitAt :: Bits b => Int -> SimpleIndexedLens Int b Bool$/;"	ft	line:63
both	src/Data/Pair/Lens.hs	/^both :: Traversal (a,a) (b,b) a b$/;"	ft	line:24
bothLenses	src/Control/Lens/Type.hs	/^bothLenses :: Lens a b c d -> Lens a' b' c' d' -> Lens (a,a') (b,b') (c,c') (d,d')$/;"	ft	line:358
bytes	src/Data/ByteString/Lazy/Lens.hs	/^bytes :: SimpleIndexedTraversal Int ByteString Word8$/;"	ft	line:39
bytes	src/Data/ByteString/Lens.hs	/^bytes :: SimpleIndexedTraversal Int ByteString Word8$/;"	ft	line:38
chars	src/Data/ByteString/Lazy/Lens.hs	/^chars :: SimpleIndexedTraversal Int ByteString Char$/;"	ft	line:64
chars	src/Data/ByteString/Lens.hs	/^chars :: SimpleIndexedTraversal Int ByteString Char$/;"	ft	line:63
children	src/Data/Tree/Lens.hs	/^children :: SimpleIndexedTraversal Int (Tree a) (Tree a)$/;"	ft	line:30
classRequired	src/Control/Lens/TH.hs	/^classRequired     :: Simple Lens LensRules Bool$/;"	ft	line:97
classy	src/Control/Lens/TH.hs	/^classy :: String -> Maybe (String, String)$/;"	ft	line:406
classyRules	src/Control/Lens/TH.hs	/^classyRules :: LensRules$/;"	ft	line:399
clone	src/Control/Lens/Type.hs	/^clone :: Functor f$/;"	ft	line:379
coerce	src/Control/Lens/Getter.hs	/^  coerce :: f a -> f b$/;"	ft	line:114
commonFieldDescs	src/Control/Lens/TH.hs	/^commonFieldDescs :: [Con] -> [FieldDesc]$/;"	ft	line:255
conFieldDescs	src/Control/Lens/TH.hs	/^conFieldDescs :: Con -> [FieldDesc]$/;"	ft	line:251
concatMapOf	src/Control/Lens/Fold.hs	/^concatMapOf :: Getting [e] a c -> (c -> [e]) -> a -> [e]$/;"	ft	line:552
concatOf	src/Control/Lens/Fold.hs	/^concatOf :: Getting [e] a [e] -> a -> [e]$/;"	ft	line:569
contains	src/Data/IntSet/Lens.hs	/^contains :: Int -> Simple Lens IntSet Bool$/;"	ft	line:28
contains	src/Data/Set/Lens.hs	/^contains :: Ord k => k -> Simple Lens (Set k) Bool$/;"	ft	line:30
createClass	src/Control/Lens/TH.hs	/^createClass       :: Simple Lens LensRules Bool$/;"	ft	line:89
createInstance	src/Control/Lens/TH.hs	/^createInstance    :: Simple Lens LensRules Bool$/;"	ft	line:93
cycled	src/Control/Lens/Fold.hs	/^cycled :: (Applicative f, Gettable f) => SimpleLensLike f a c -> SimpleLensLike f a c$/;"	ft	line:152
defaultRules	src/Control/Lens/TH.hs	/^defaultRules :: LensRules$/;"	ft	line:130
distributeRep	src/Control/Lens/Representable.hs	/^distributeRep :: (Representable f, Functor w) => w (f a) -> f (w a)$/;"	ft	line:199
droppingWhile	src/Control/Lens/Fold.hs	/^droppingWhile :: (Gettable f, Applicative f)$/;"	ft	line:208
effective	src/Control/Lens/Action.hs	/^  effective :: Isomorphic k => k (m r) (f a)$/;"	ft	line:65
elemOf	src/Control/Lens/Fold.hs	/^elemOf :: Eq c => Getting Any a c -> c -> a -> Bool$/;"	ft	line:524
element	src/Control/Lens/Traversal.hs	/^element :: Traversable t => Int -> Simple Lens (t a) a$/;"	ft	line:306
elementOf	src/Control/Lens/Traversal.hs	/^elementOf :: Functor f => LensLike (ElementOf f) a b c c -> Int -> LensLike f a b c c$/;"	ft	line:293
errorClause	src/Control/Lens/TH.hs	/^errorClause :: Name -> Name -> Name -> ClauseQ$/;"	ft	line:262
evalOf	src/Control/Parallel/Strategies/Lens.hs	/^evalOf :: SimpleLensLike Eval a b -> Strategy b -> Strategy a$/;"	ft	line:37
every	src/GHC/Generics/Lens.hs	/^every :: (Generic a, GTraversal (Rep a), Typeable b) => Simple Traversal a b$/;"	ft	line:63
everyr	src/GHC/Generics/Lens.hs	/^  everyr :: Typeable b => Bool -> Simple Traversal (f a) b$/;"	ft	line:68
f	src/Control/Lens/Indexed.hs	/^f <.> g = icompose (,) f g$/;"	fi	line:83
f	src/Control/Lens/Representable.hs	/^type Rep f = forall a. Simple Lens (f a) a$/;"	fi	line:90
f	src/Control/Lens/Type.hs	/^type Simple f a b = f a a b b$/;"	fi	line:163
fieldDescs	src/Control/Lens/TH.hs	/^fieldDescs :: Set Name -> [(Name,Strict,Type)] -> [FieldDesc]$/;"	ft	line:245
filtered	src/Control/Lens/Fold.hs	/^filtered :: (Gettable f, Applicative f) => (c -> Bool) -> SimpleLensLike f a c -> SimpleLensLike f a c$/;"	ft	line:174
findOf	src/Control/Lens/Fold.hs	/^findOf :: Getting (First c) a c -> (c -> Bool) -> a -> Maybe c$/;"	ft	line:734
fmapRep	src/Control/Lens/Representable.hs	/^fmapRep :: Representable f => (a -> b) -> f a -> f b$/;"	ft	line:131
focus	src/Control/Lens/Type.hs	/^  focus :: Monad m => LensLike (Focusing m c) a a b b -> st b m c -> st a m c$/;"	ft	line:269
focus_	src/Control/Lens/Type.hs	/^  focus_ :: Monad m => LensLike (Focusing m ()) a a b b -> st b m c -> st a m ()$/;"	ft	line:278
foldMapOf	src/Control/Lens/Fold.hs	/^foldMapOf :: Getting r a c -> (c -> r) -> a -> r$/;"	ft	line:231
foldMapWithRep	src/Control/Lens/Representable.hs	/^foldMapWithRep :: (Representable f, Foldable f, Monoid m)$/;"	ft	line:281
foldOf	src/Control/Lens/Fold.hs	/^foldOf :: Getting c a c -> a -> c$/;"	ft	line:247
folded	src/Control/Lens/Fold.hs	/^folded :: Foldable f => Fold (f c) c$/;"	ft	line:127
folding	src/Control/Lens/Fold.hs	/^folding :: (Foldable f, Applicative g, Gettable g) => (a -> f c) -> LensLike g a b c d$/;"	ft	line:113
foldl1Of	src/Control/Lens/Fold.hs	/^foldl1Of :: Getting (Dual (Endo (Maybe c))) a c -> (c -> c -> c) -> a -> c$/;"	ft	line:778
foldlMOf	src/Control/Lens/Fold.hs	/^foldlMOf :: Monad m$/;"	ft	line:847
foldlOf	src/Control/Lens/Fold.hs	/^foldlOf :: Getting (Dual (Endo e)) a c -> (e -> c -> e) -> e -> a -> e$/;"	ft	line:279
foldlOf'	src/Control/Lens/Fold.hs	/^foldlOf' :: Getting (Endo (e -> e)) a c -> (e -> c -> e) -> e -> a -> e$/;"	ft	line:811
foldr1Of	src/Control/Lens/Fold.hs	/^foldr1Of :: Getting (Endo (Maybe c)) a c -> (c -> c -> c) -> a -> c$/;"	ft	line:757
foldrMOf	src/Control/Lens/Fold.hs	/^foldrMOf :: Monad m$/;"	ft	line:828
foldrOf	src/Control/Lens/Fold.hs	/^foldrOf :: Getting (Endo e) a c -> (c -> e -> e) -> e -> a -> e$/;"	ft	line:263
foldrOf'	src/Control/Lens/Fold.hs	/^foldrOf' :: Getting (Dual (Endo (e -> e))) a c -> (c -> e -> e) -> e -> a -> e$/;"	ft	line:795
foldrWithRep	src/Control/Lens/Representable.hs	/^foldrWithRep :: (Representable f, Foldable f) => (Rep f -> a -> b -> b) -> b -> f a -> b$/;"	ft	line:288
forMOf	src/Control/Lens/Traversal.hs	/^forMOf :: LensLike (WrappedMonad m) a b c d -> a -> (c -> m d) -> m b$/;"	ft	line:181
forMOf_	src/Control/Lens/Fold.hs	/^forMOf_ :: Monad m => Getting (Sequenced m) a c -> a -> (c -> m e) -> m ()$/;"	ft	line:466
forMWithRep	src/Control/Lens/Representable.hs	/^forMWithRep :: (Representable f, Traversable f, Monad m)$/;"	ft	line:274
forOf	src/Control/Lens/Traversal.hs	/^forOf :: LensLike f a b c d -> a -> (c -> f d) -> f b$/;"	ft	line:133
forOf_	src/Control/Lens/Fold.hs	/^forOf_ :: Functor f => Getting (Traversed f) a c -> a -> (c -> f e) -> f ()$/;"	ft	line:420
forWithRep	src/Control/Lens/Representable.hs	/^forWithRep :: (Representable f, Traversable f, Applicative g)$/;"	ft	line:253
freshMap	src/Control/Lens/TH.hs	/^freshMap :: Set Name -> Q (Map Name Name)$/;"	ft	line:140
from	src/Control/Lens/Iso.hs	/^from :: Isomorphic k => Isomorphism a b -> k b a$/;"	ft	line:92
generic	src/GHC/Generics/Lens.hs	/^generic :: Generic a => Simple Iso a (Rep a b)$/;"	ft	line:47
generic1	src/GHC/Generics/Lens.hs	/^generic1 :: Generic1 f => Simple Iso (f a) (Rep1 f a)$/;"	ft	line:51
getEffect	src/Control/Lens/Action.hs	/^newtype Effect m r a = Effect { getEffect :: m r }$/;"	c_a	line:82
getElementOf	src/Control/Lens/Internal.hs	/^newtype ElementOf f a = ElementOf { getElementOf :: Int -> ElementOfResult f a }$/;"	c_a	line:136
getGA	src/Control/Lens/Fold.hs	/^newtype GA f a = GA { getGA :: f a }$/;"	c_a	line:118
getMax	src/Control/Lens/Internal.hs	/^getMax :: Max a -> Maybe a$/;"	ft	line:120
getMin	src/Control/Lens/Internal.hs	/^getMin :: Min a -> Maybe a$/;"	ft	line:106
getSequenced	src/Control/Lens/Internal.hs	/^newtype Sequenced m = Sequenced { getSequenced :: m () }$/;"	c_a	line:90
getTraversed	src/Control/Lens/Internal.hs	/^newtype Traversed f = Traversed { getTraversed :: f () }$/;"	c_a	line:83
handleSingletons	src/Control/Lens/TH.hs	/^handleSingletons :: Simple Lens LensRules Bool$/;"	ft	line:73
headOf	src/Control/Lens/Fold.hs	/^headOf :: Getting (First c) a c -> a -> Maybe c$/;"	ft	line:606
i	src/Control/Lens/Indexed.hs	/^type Indexable i a b = forall k. Indexed i k => k a b$/;"	fi	line:39
i	src/Control/Lens/IndexedFold.hs	/^type IndexedFold i a c = forall k f. (Indexed i k, Applicative f, Gettable f) => k (c -> f c) (a -> f a)$/;"	fi	line:58
i	src/Control/Lens/IndexedGetter.hs	/^type IndexedGetter i a c = forall k f. (Indexed i k, Gettable f) => k (c -> f c) (a -> f a)$/;"	fi	line:28
i	src/Control/Lens/IndexedLens.hs	/^type IndexedLens i a b c d = forall f k. (Indexed i k, Functor f) => k (c -> f d) (a -> f b)$/;"	fi	line:43
i	src/Control/Lens/IndexedSetter.hs	/^type IndexedSetter i a b c d = forall f k. (Indexed i k, Settable f) => k (c -> f d) (a -> f b)$/;"	fi	line:38
i	src/Control/Lens/IndexedTraversal.hs	/^type IndexedTraversal i a b c d = forall f k. (Indexed i k, Applicative f) => k (c -> f d) (a -> f b)$/;"	fi	line:46
iallOf	src/Control/Lens/IndexedFold.hs	/^iallOf :: IndexedGetting i All a c -> (i -> c -> Bool) -> a -> Bool$/;"	ft	line:146
ianyOf	src/Control/Lens/IndexedFold.hs	/^ianyOf :: IndexedGetting i Any a c -> (i -> c -> Bool) -> a -> Bool$/;"	ft	line:128
icompose	src/Control/Lens/Indexed.hs	/^icompose :: Indexed k r => (i -> j -> k) -> Index i b c -> Index j a b -> r a c$/;"	ft	line:89
iconcatMapOf	src/Control/Lens/IndexedFold.hs	/^iconcatMapOf :: IndexedGetting i [e] a c -> (i -> c -> [e]) -> a -> [e]$/;"	ft	line:243
identity	src/Control/Lens/Iso.hs	/^identity :: Iso a b (Identity a) (Identity b)$/;"	ft	line:172
idroppingWhile	src/Control/Lens/IndexedFold.hs	/^idroppingWhile :: (Gettable f, Applicative f, Indexed i k)$/;"	ft	line:371
ifiltered	src/Control/Lens/IndexedFold.hs	/^ifiltered :: (Gettable f, Applicative f, Indexed i k) => (i -> c -> Bool) -> Index i (c -> f c) (a -> f a) -> k (c -> f c) (a -> f a)$/;"	ft	line:357
ifindOf	src/Control/Lens/IndexedFold.hs	/^ifindOf :: IndexedGetting i (First (i, c)) a c -> (i -> c -> Bool) -> a -> Maybe (i, c)$/;"	ft	line:261
ifoldMapOf	src/Control/Lens/IndexedFold.hs	/^ifoldMapOf :: IndexedGetting i m a c -> (i -> c -> m) -> a -> m$/;"	ft	line:74
ifoldlMOf	src/Control/Lens/IndexedFold.hs	/^ifoldlMOf :: Monad m => IndexedGetting i (Endo (e -> m e)) a c -> (i -> e -> c -> m e) -> e -> a -> m e$/;"	ft	line:331
ifoldlOf	src/Control/Lens/IndexedFold.hs	/^ifoldlOf :: IndexedGetting i (Dual (Endo e)) a c -> (i -> e -> c -> e) -> e -> a -> e$/;"	ft	line:110
ifoldlOf'	src/Control/Lens/IndexedFold.hs	/^ifoldlOf' :: IndexedGetting i (Endo (e -> e)) a c -> (i -> e -> c -> e) -> e -> a -> e$/;"	ft	line:297
ifoldrMOf	src/Control/Lens/IndexedFold.hs	/^ifoldrMOf :: Monad m => IndexedGetting i (Dual (Endo (e -> m e))) a c -> (i -> c -> e -> m e) -> e -> a -> m e$/;"	ft	line:314
ifoldrOf	src/Control/Lens/IndexedFold.hs	/^ifoldrOf :: IndexedGetting i (Endo e) a c -> (i -> c -> e -> e) -> e -> a -> e$/;"	ft	line:92
ifoldrOf'	src/Control/Lens/IndexedFold.hs	/^ifoldrOf' :: IndexedGetting i (Dual (Endo (e -> e))) a c -> (i -> c -> e -> e) -> e -> a -> e$/;"	ft	line:280
iforMOf	src/Control/Lens/IndexedTraversal.hs	/^iforMOf :: Overloaded (Index i) (WrappedMonad m) a b c d -> a -> (i -> c -> m d) -> m b$/;"	ft	line:113
iforMOf_	src/Control/Lens/IndexedFold.hs	/^iforMOf_ :: Monad m => IndexedGetting i (Sequenced m) a c -> a -> (i -> c -> m e) -> m ()$/;"	ft	line:225
iforOf	src/Control/Lens/IndexedTraversal.hs	/^iforOf :: Overloaded (Index i) f a b c d -> a -> (i -> c -> f d) -> f b$/;"	ft	line:80
iforOf_	src/Control/Lens/IndexedFold.hs	/^iforOf_ :: Functor f => IndexedGetting i (Traversed f) a c -> a -> (i -> c -> f e) -> f ()$/;"	ft	line:183
imaginary	src/Data/Complex/Lens.hs	/^imaginary :: Simple Lens (Complex a) a$/;"	ft	line:35
imapAccumLOf	src/Control/Lens/IndexedTraversal.hs	/^imapAccumLOf :: Overloaded (Index i) (Backwards (Lazy.State s)) a b c d -> (i -> s -> c -> (s, d)) -> s -> a -> (s, b)$/;"	ft	line:141
imapAccumROf	src/Control/Lens/IndexedTraversal.hs	/^imapAccumROf :: Overloaded (Index i) (Lazy.State s) a b c d -> (i -> s -> c -> (s, d)) -> s -> a -> (s, b)$/;"	ft	line:127
imapMOf	src/Control/Lens/IndexedTraversal.hs	/^imapMOf :: Overloaded (Index i) (WrappedMonad m) a b c d -> (i -> c -> m d) -> a -> m b$/;"	ft	line:96
imapMOf_	src/Control/Lens/IndexedFold.hs	/^imapMOf_ :: Monad m => IndexedGetting i (Sequenced m) a c -> (i -> c -> m e) -> a -> m ()$/;"	ft	line:201
imapOf	src/Control/Lens/IndexedSetter.hs	/^imapOf :: Overloaded (Index i) Mutator a b c d -> (i -> c -> d) -> a -> b$/;"	ft	line:55
index	src/Control/Lens/Indexed.hs	/^  index :: ((i -> a) -> b) -> k a b$/;"	ft	line:35
ineffective	src/Control/Lens/Action.hs	/^ineffective :: Effective m r f => Isomorphic k => k (f a) (m r)$/;"	ft	line:68
infix	src/Control/Lens/IndexedLens.hs	/^infix  4 %%@=, <%@=$/;"	fi	line:40
infix	src/Control/Lens/IndexedSetter.hs	/^infix  4 %@=$/;"	fi	line:33
infix	src/Control/Lens/Setter.hs	/^infix  4 .=, +=, *=, -=, \/\/=, ^=, ^^=, **=, &&=, ||=, %=, <>=, <.=$/;"	fi	line:59
infix	src/Control/Lens/Type.hs	/^infix  4 %%=$/;"	fi	line:108
infix	src/Data/Bits/Lens.hs	/^infix 4 |=, &=$/;"	fi	line:26
instance	src/Control/Lens/Action.hs	/^instance Effective Identity r (Accessor r) where$/;"	fi	line:72
instance	src/Control/Lens/Fold.hs	/^instance (Gettable f, Applicative f) => Monoid (GA f a) where$/;"	fi	line:120
instance	src/Control/Lens/Getter.hs	/^instance Gettable (Const r) where$/;"	fi	line:116
instance	src/Control/Lens/Indexed.hs	/^instance Indexed i (->) where$/;"	fi	line:41
instance	src/Control/Lens/Internal.hs	/^instance Monad m => Functor (Focusing m c) where$/;"	fi	line:46
instance	src/Control/Lens/Iso.hs	/^instance Isomorphic (->) where$/;"	fi	line:58
instance	src/Control/Lens/Representable.hs	/^instance Representable Identity where$/;"	fi	line:112
instance	src/Control/Lens/Setter.hs	/^instance Settable Identity where$/;"	fi	line:128
instance	src/Control/Lens/TH.hs	/^instance Applicative Q where$/;"	fi	line:442
instance	src/Control/Lens/Type.hs	/^instance Focus Strict.StateT where$/;"	fi	line:287
instance	src/GHC/Generics/Lens.hs	/^instance (Generic a, GTraversal (Rep a), Typeable a) => GTraversal (K1 i a) where$/;"	fi	line:70
instance	src/Language/Haskell/TH/Lens.hs	/^instance HasName TyVarBndr where$/;"	fi	line:43
intercalated	src/Data/List/Lens.hs	/^intercalated :: [a] -> Getter [[a]] [a]$/;"	ft	line:84
interspersed	src/Data/List/Lens.hs	/^interspersed :: a -> Getter [a] [a]$/;"	ft	line:79
iso	src/Control/Lens/Iso.hs	/^iso :: (Isomorphic k, Functor f) => (a -> b) -> (b -> a) -> k (b -> f b) (a -> f a)$/;"	ft	line:156
isoRules	src/Control/Lens/TH.hs	/^isoRules :: LensRules$/;"	ft	line:386
isomap	src/Control/Lens/Iso.hs	/^  isomap :: ((a -> b) -> c -> d) -> ((b -> a) -> d -> c) -> k a b -> k c d$/;"	ft	line:56
isomorphic	src/Control/Lens/Iso.hs	/^  isomorphic :: (a -> b) -> (b -> a) -> k a b$/;"	ft	line:52
isos	src/Control/Lens/Iso.hs	/^isos :: (Isomorphic k, Functor f) => (a -> c) -> (c -> a) -> (b -> d) -> (d -> b) -> k (c -> f d) (a -> f b)$/;"	ft	line:137
itakingWhile	src/Control/Lens/IndexedFold.hs	/^itakingWhile :: (Gettable f, Applicative f, Indexed i k)$/;"	ft	line:362
iterated	src/Control/Lens/Fold.hs	/^iterated :: (a -> a) -> Fold a a$/;"	ft	line:168
itoListOf	src/Control/Lens/IndexedFold.hs	/^itoListOf :: IndexedGetting i [(i,c)] a c -> a -> [(i,c)]$/;"	ft	line:348
itraverseOf	src/Control/Lens/IndexedTraversal.hs	/^itraverseOf :: Overloaded (Index i) f a b c d -> (i -> c -> f d) -> a -> f b$/;"	ft	line:65
itraverseOf_	src/Control/Lens/IndexedFold.hs	/^itraverseOf_ :: Functor f => IndexedGetting i (Traversed f) a c -> (i -> c -> f e) -> a -> f ()$/;"	ft	line:163
ix	src/Data/Array/Lens.hs	/^ix :: (IArray a e, Ix i) => i -> Simple Lens (a i e) e$/;"	ft	line:38
ixmapped	src/Data/Array/Lens.hs	/^ixmapped :: (IArray a e, Ix i, Ix j) => (i,i) -> Setter (a j e) (a i e) i j$/;"	ft	line:54
k	src/Control/Lens/Action.hs	/^  effective :: Isomorphic k => k (m r) (f a)$/;"	c	line:65
k	src/Control/Lens/Type.hs	/^type Overloaded k f a b c d = k (c -> f d) (a -> f b)$/;"	fi	line:391
l	src/Control/Lens/Getter.hs	/^l ^$ a = runAccessor (l Accessor a)$/;"	fi	line:213
l	src/Control/Lens/IndexedLens.hs	/^l <%@~ f = withIndex l $ \\i c -> let d = f i c in (d, d)$/;"	fi	line:63
l	src/Control/Lens/IndexedSetter.hs	/^l %@~ f = runMutator . withIndex l (\\i -> Mutator . f i)$/;"	fi	line:74
l	src/Control/Lens/Setter.hs	/^l <.~ d = \\a -> (d, l .~ d $ a)$/;"	fi	line:321
l	src/Control/Lens/Type.hs	/^l %%= f = State.state (l f)$/;"	fi	line:244
l	src/Data/Bits/Lens.hs	/^l |~ n = adjust l (.|. n)$/;"	fi	line:33
lastOf	src/Control/Lens/Fold.hs	/^lastOf :: Getting (Last c) a c -> a -> Maybe c$/;"	ft	line:620
lengthOf	src/Control/Lens/Fold.hs	/^lengthOf :: Getting (Sum Int) a c -> a -> Int$/;"	ft	line:590
lens	src/Control/Lens/Type.hs	/^lens :: (a -> c) -> (a -> d -> b) -> Lens a b c d$/;"	ft	line:178
lensClass	src/Control/Lens/TH.hs	/^lensClass :: Simple Lens LensRules (String -> Maybe (String, String))$/;"	ft	line:122
lensField	src/Control/Lens/TH.hs	/^lensField :: Simple Lens LensRules (String -> Maybe String)$/;"	ft	line:118
lensFlags	src/Control/Lens/TH.hs	/^lensFlags :: Simple Lens LensRules (Set LensFlag)$/;"	ft	line:126
lensIso	src/Control/Lens/TH.hs	/^lensIso :: Simple Lens LensRules (String -> Maybe String)$/;"	ft	line:111
lensRules	src/Control/Lens/TH.hs	/^lensRules :: LensRules$/;"	ft	line:421
liftAct	src/Control/Lens/Action.hs	/^liftAct :: (MonadTrans t, Monad m) => Acting m c a c -> Action (t m) a c$/;"	ft	line:144
m	src/Control/Lens/Action.hs	/^type Action m a c = forall f r. Effective m r f => (c -> f c) -> a -> f a$/;"	fi	line:52
makeClassy	src/Control/Lens/TH.hs	/^makeClassy :: Name -> Q [Dec]$/;"	ft	line:395
makeClassyFor	src/Control/Lens/TH.hs	/^makeClassyFor :: String -> String -> [(String, String)] -> Name -> Q [Dec]$/;"	ft	line:434
makeFieldLensBody	src/Control/Lens/TH.hs	/^makeFieldLensBody :: Name -> Name -> [Con] -> Maybe Name -> Q Dec$/;"	ft	line:270
makeFieldLenses	src/Control/Lens/TH.hs	/^makeFieldLenses :: LensRules$/;"	ft	line:293
makeIso	src/Control/Lens/TH.hs	/^makeIso :: Name -> Q [Dec]$/;"	ft	line:382
makeIsoBody	src/Control/Lens/TH.hs	/^makeIsoBody :: Name -> Name -> (Name -> ExpQ) -> (Name -> ExpQ) -> DecQ$/;"	ft	line:157
makeIsoFrom	src/Control/Lens/TH.hs	/^makeIsoFrom :: Name -> ExpQ$/;"	ft	line:150
makeIsoLenses	src/Control/Lens/TH.hs	/^makeIsoLenses :: LensRules$/;"	ft	line:196
makeIsoLenses	src/Control/Lens/TH.hs	/^makeIsoLenses cfg ctx tyConName tyArgs0 dataConName maybeFieldName partTy = do$/;"	fi	line:204
makeIsoTo	src/Control/Lens/TH.hs	/^makeIsoTo :: Name -> ExpQ$/;"	ft	line:143
makeLensBody	src/Control/Lens/TH.hs	/^makeLensBody :: Name -> Name -> (Name -> ExpQ) -> (Name -> ExpQ) -> DecQ$/;"	ft	line:164
makeLenses	src/Control/Lens/TH.hs	/^makeLenses :: Name -> Q [Dec]$/;"	ft	line:374
makeLensesFor	src/Control/Lens/TH.hs	/^makeLensesFor :: [(String, String)] -> Name -> Q [Dec]$/;"	ft	line:415
makeLensesWith	src/Control/Lens/TH.hs	/^makeLensesWith :: LensRules -> Name -> Q [Dec]$/;"	ft	line:354
mapAccumLOf	src/Control/Lens/Traversal.hs	/^mapAccumLOf :: LensLike (Backwards (Lazy.State s)) a b c d -> (s -> c -> (s, d)) -> s -> a -> (s, b)$/;"	ft	line:244
mapAccumROf	src/Control/Lens/Traversal.hs	/^mapAccumROf :: LensLike (Lazy.State s) a b c d -> (s -> c -> (s, d)) -> s -> a -> (s, b)$/;"	ft	line:229
mapMOf	src/Control/Lens/Traversal.hs	/^mapMOf :: LensLike (WrappedMonad m) a b c d -> (c -> m d) -> a -> m b$/;"	ft	line:166
mapMOf_	src/Control/Lens/Fold.hs	/^mapMOf_ :: Monad m => Getting (Sequenced m) a c -> (c -> m e) -> a -> m ()$/;"	ft	line:448
mapMWithRep	src/Control/Lens/Representable.hs	/^mapMWithRep :: (Representable f, Traversable f, Monad m)$/;"	ft	line:260
mapMWithRep_	src/Control/Lens/Representable.hs	/^mapMWithRep_ :: (Representable f, Foldable f, Monad m)$/;"	ft	line:267
mapOf	src/Control/Lens/Setter.hs	/^mapOf :: Setting a b c d -> (c -> d) -> a -> b$/;"	ft	line:234
mapWithRep	src/Control/Lens/Representable.hs	/^mapWithRep :: Representable f => (Rep f -> a -> b) -> f a -> f b$/;"	ft	line:234
mapped	src/Control/Lens/Setter.hs	/^mapped :: Functor f => Setter (f a) (f b) a b$/;"	ft	line:169
maximumByOf	src/Control/Lens/Fold.hs	/^maximumByOf :: Getting (Endo (Maybe c)) a c -> (c -> c -> Ordering) -> a -> Maybe c$/;"	ft	line:698
maximumOf	src/Control/Lens/Fold.hs	/^maximumOf :: Getting (Max c) a c -> a -> Maybe c$/;"	ft	line:663
meanwhile	src/Control/Parallel/Strategies/Lens.hs	/^meanwhile :: Strategy a -> LensLike f a b c d -> LensLike f a b c d$/;"	ft	line:68
members	src/Data/IntSet/Lens.hs	/^members :: Fold IntSet Int$/;"	ft	line:38
merged	src/Control/Lens/Type.hs	/^merged :: Functor f => LensLike f a b c c -> LensLike f a' b' c c -> LensLike f (Either a a') (Either b b') c c$/;"	ft	line:352
minimumByOf	src/Control/Lens/Fold.hs	/^minimumByOf :: Getting (Endo (Maybe c)) a c -> (c -> c -> Ordering) -> a -> Maybe c$/;"	ft	line:717
minimumOf	src/Control/Lens/Fold.hs	/^minimumOf :: Getting (Min c) a c -> a -> Maybe c$/;"	ft	line:681
msumOf	src/Control/Lens/Fold.hs	/^msumOf :: MonadPlus m => Getting (Endo (m c)) a (m c) -> a -> m c$/;"	ft	line:510
name	src/Language/Haskell/TH/Lens.hs	/^  name :: Simple Lens t Name$/;"	ft	line:41
noEffect	src/Control/Lens/Fold.hs	/^noEffect :: (Applicative f, Gettable f) => f a$/;"	ft	line:106
noEffect	src/Control/Lens/IndexedFold.hs	/^noEffect :: (Applicative f, Gettable f) => f a$/;"	ft	line:352
notElemOf	src/Control/Lens/Fold.hs	/^notElemOf :: Eq c => Getting All a c -> c -> a -> Bool$/;"	ft	line:538
nullOf	src/Control/Lens/Fold.hs	/^nullOf :: Getting All a c -> a -> Bool$/;"	ft	line:645
orOf	src/Control/Lens/Fold.hs	/^orOf :: Getting Any a Bool -> a -> Bool$/;"	ft	line:321
packed	src/Data/Text/Lazy/Lens.hs	/^packed :: Simple Iso String Text$/;"	ft	line:23
packed	src/Data/Text/Lens.hs	/^packed :: Simple Iso String Text$/;"	ft	line:25
packedBytes	src/Data/ByteString/Lazy/Lens.hs	/^packedBytes :: Simple Iso [Word8] ByteString$/;"	ft	line:29
packedBytes	src/Data/ByteString/Lens.hs	/^packedBytes :: Simple Iso [Word8] ByteString$/;"	ft	line:28
packedChars	src/Data/ByteString/Lazy/Lens.hs	/^packedChars :: Simple Iso String ByteString$/;"	ft	line:51
packedChars	src/Data/ByteString/Lens.hs	/^packedChars :: Simple Iso String ByteString$/;"	ft	line:50
parOf	src/Control/Parallel/Strategies/Lens.hs	/^parOf :: SimpleLensLike Eval a b -> Strategy b -> Strategy a$/;"	ft	line:50
paths	src/Control/Lens/Representable.hs	/^paths :: Representable f => f (Path f)$/;"	ft	line:215
perform	src/Control/Lens/Action.hs	/^perform :: Monad m => Acting m c a c -> a -> m c$/;"	ft	line:110
plain	src/Control/Lens/TH.hs	/^plain :: TyVarBndr -> TyVarBndr$/;"	ft	line:167
polarize	src/Data/Complex/Lens.hs	/^polarize :: (RealFloat a, RealFloat b) => Iso (Complex a) (Complex b) (a,a) (b,b)$/;"	ft	line:50
productOf	src/Control/Lens/Fold.hs	/^productOf :: Getting (Product c) a c -> a -> c$/;"	ft	line:363
pureRep	src/Control/Lens/Representable.hs	/^pureRep :: Representable f => a -> f a$/;"	ft	line:153
queries	src/Control/Lens/Getter.hs	/^queries :: MonadReader a m => Getting e a c -> (c -> e) -> m e$/;"	ft	line:269
query	src/Control/Lens/Getter.hs	/^query :: MonadReader a m => Getting c a c -> m c$/;"	ft	line:254
r	src/Control/Lens/Getter.hs	/^type Getting r a c = (c -> Accessor r c) -> a -> Accessor r a$/;"	fi	line:97
real	src/Data/Complex/Lens.hs	/^real :: Simple Lens (Complex a) a$/;"	ft	line:25
reindex	src/Control/Lens/Indexed.hs	/^reindex :: Indexed j k => (i -> j) -> Index i a b -> k a b$/;"	ft	line:74
rep	src/Control/Lens/Representable.hs	/^  rep :: (Rep f -> a) -> f a$/;"	ft	line:109
repeated	src/Control/Lens/Fold.hs	/^repeated :: Fold a a$/;"	ft	line:134
replicated	src/Control/Lens/Fold.hs	/^replicated :: Int -> Fold a a$/;"	ft	line:140
resultAt	src/Control/Lens/Type.hs	/^resultAt :: Eq e => e -> Simple Lens (e -> a) a$/;"	ft	line:344
root	src/Data/Tree/Lens.hs	/^root :: Simple Lens (Tree a) a$/;"	ft	line:24
runAccessor	src/Control/Lens/Getter.hs	/^newtype Accessor r a = Accessor { runAccessor :: r }$/;"	c_a	line:138
runAppliedState	src/Control/Lens/Internal.hs	/^newtype AppliedState f a = AppliedState { runAppliedState :: Int -> (f a, Int) }$/;"	c_a	line:69
runMutator	src/Control/Lens/Setter.hs	/^newtype Mutator a = Mutator { runMutator :: a }$/;"	c_a	line:145
scanl1Of	src/Control/Lens/Traversal.hs	/^scanl1Of :: LensLike (Backwards (Lazy.State (Maybe c))) a b c c -> (c -> c -> c) -> a -> b$/;"	ft	line:276
scanr1Of	src/Control/Lens/Traversal.hs	/^scanr1Of :: LensLike (Lazy.State (Maybe c)) a b c c -> (c -> c -> c) -> a -> b$/;"	ft	line:261
seqOf	src/Control/Seq/Lens.hs	/^seqOf :: Getting [c] a c -> Strategy c -> Strategy a$/;"	ft	line:23
sequenceAOf	src/Control/Lens/Traversal.hs	/^sequenceAOf :: LensLike f a b (f c) c -> a -> f b$/;"	ft	line:152
sequenceAOf_	src/Control/Lens/Fold.hs	/^sequenceAOf_ :: Functor f => Getting (Traversed f) a (f ()) -> a -> f ()$/;"	ft	line:434
sequenceOf	src/Control/Lens/Traversal.hs	/^sequenceOf :: LensLike (WrappedMonad m) a b (m c) c -> a -> m b$/;"	ft	line:197
sequenceOf_	src/Control/Lens/Fold.hs	/^sequenceOf_ :: Monad m => Getting (Sequenced m) a (m c) -> a -> m ()$/;"	ft	line:480
set	src/Control/Lens/Setter.hs	/^set :: Setting a b c d -> d -> a -> b$/;"	ft	line:259
setFocus	src/Control/Lens/Type.hs	/^  setFocus :: Simple Setter a b -> st b Identity c -> st a Identity ()$/;"	ft	line:281
setOf	src/Data/IntSet/Lens.hs	/^setOf :: Getting IntSet a Int -> a -> IntSet$/;"	ft	line:66
setOf	src/Data/Set/Lens.hs	/^setOf :: Getting (Set c) a c -> a -> Set c$/;"	ft	line:61
setmapped	src/Data/IntSet/Lens.hs	/^setmapped :: Simple Setter IntSet Int$/;"	ft	line:50
setmapped	src/Data/Set/Lens.hs	/^setmapped :: (Ord i, Ord j) => Setter (Set i) (Set j) i j$/;"	ft	line:45
sets	src/Control/Lens/Setter.hs	/^sets :: ((c -> d) -> a -> b) -> Setter a b c d$/;"	ft	line:191
simpleLenses	src/Control/Lens/TH.hs	/^simpleLenses      :: Simple Lens LensRules Bool$/;"	ft	line:69
singletonAndField	src/Control/Lens/TH.hs	/^singletonAndField :: Simple Lens LensRules Bool$/;"	ft	line:77
singletonIso	src/Control/Lens/TH.hs	/^singletonIso :: Simple Lens LensRules Bool$/;"	ft	line:81
singletonRequired	src/Control/Lens/TH.hs	/^singletonRequired  :: Simple Lens LensRules Bool$/;"	ft	line:85
skip	src/Control/Lens/Fold.hs	/^skip :: a -> ()$/;"	ft	line:452
skip	src/Control/Lens/IndexedFold.hs	/^skip :: a -> ()$/;"	ft	line:205
skip	src/Control/Lens/Type.hs	/^skip :: a -> ()$/;"	ft	line:283
substType	src/Language/Haskell/TH/Lens.hs	/^  substType :: Map Name Type -> t -> t$/;"	ft	line:99
substTypeVars	src/Language/Haskell/TH/Lens.hs	/^substTypeVars :: HasTypeVars t => Map Name Name -> t -> t$/;"	ft	line:93
sumOf	src/Control/Lens/Fold.hs	/^sumOf :: Getting (Sum c) a c -> a -> c$/;"	ft	line:381
swap	src/Control/Lens/IndexedTraversal.hs	/^swap :: (a,b) -> (b,a)$/;"	ft	line:145
swap	src/Control/Lens/Traversal.hs	/^swap :: (a,b) -> (b,a)$/;"	ft	line:248
tabulated	src/Control/Lens/Representable.hs	/^tabulated :: (Isomorphic k, Representable f) => k (Path f -> a) (f a)$/;"	ft	line:221
takingWhile	src/Control/Lens/Fold.hs	/^takingWhile :: (Gettable f, Applicative f)$/;"	ft	line:194
text	src/Data/Text/Lazy/Lens.hs	/^text :: Simple Traversal Text Char$/;"	ft	line:31
text	src/Data/Text/Lens.hs	/^text :: SimpleIndexedTraversal Int Text Char$/;"	ft	line:33
thd	src/Control/Lens/TH.hs	/^thd :: (a,b,c) -> c$/;"	ft	line:242
to	src/Control/Lens/Getter.hs	/^to :: (a -> c) -> Getter a c$/;"	ft	line:85
toListOf	src/Control/Lens/Fold.hs	/^toListOf :: Getting [c] a c -> a -> [c]$/;"	ft	line:293
transposeOf	src/Control/Lens/Traversal.hs	/^transposeOf :: LensLike ZipList a b [c] c -> a -> [b]$/;"	ft	line:214
traverseArray	src/Data/Array/Lens.hs	/^traverseArray :: (IArray a c, IArray a d, Ix i) => IndexedTraversal i (a i c) (a i d) c d$/;"	ft	line:62
traverseAt	src/Data/IntMap/Lens.hs	/^traverseAt :: Int -> SimpleIndexedTraversal Int (IntMap v) v$/;"	ft	line:52
traverseAt	src/Data/Map/Lens.hs	/^traverseAt :: Ord k => k -> SimpleIndexedTraversal k (Map k v) v$/;"	ft	line:55
traverseAtMax	src/Data/IntMap/Lens.hs	/^traverseAtMax :: SimpleIndexedTraversal Int (IntMap v) v$/;"	ft	line:70
traverseAtMax	src/Data/Map/Lens.hs	/^traverseAtMax :: SimpleIndexedTraversal k (Map k v) v$/;"	ft	line:71
traverseAtMin	src/Data/IntMap/Lens.hs	/^traverseAtMin :: SimpleIndexedTraversal Int (IntMap v) v$/;"	ft	line:59
traverseAtMin	src/Data/Map/Lens.hs	/^traverseAtMin :: SimpleIndexedTraversal k (Map k v) v$/;"	ft	line:62
traverseBits	src/Data/Bits/Lens.hs	/^traverseBits :: Bits b => SimpleIndexedTraversal Int b Bool$/;"	ft	line:77
traverseComplex	src/Data/Complex/Lens.hs	/^traverseComplex :: Traversal (Complex a) (Complex b) a b$/;"	ft	line:58
traverseDynamic	src/Data/Dynamic/Lens.hs	/^traverseDynamic :: (Typeable a, Typeable b) => Traversal Dynamic Dynamic a b$/;"	ft	line:24
traverseException	src/Control/Exception/Lens.hs	/^traverseException :: (Exception a, Exception b) => Traversal SomeException SomeException a b$/;"	ft	line:27
traverseFrom	src/Data/Sequence/Lens.hs	/^traverseFrom :: Int -> SimpleIndexedTraversal Int (Seq a) a$/;"	ft	line:98
traverseHead	src/Data/List/Lens.hs	/^traverseHead :: SimpleIndexedTraversal Int [a] a$/;"	ft	line:103
traverseHead	src/Data/Sequence/Lens.hs	/^traverseHead :: SimpleIndexedTraversal Int (Seq a) a$/;"	ft	line:64
traverseInit	src/Data/List/Lens.hs	/^traverseInit :: SimpleIndexedTraversal Int [a] a$/;"	ft	line:147
traverseInit	src/Data/Sequence/Lens.hs	/^traverseInit :: SimpleIndexedTraversal Int (Seq a) a$/;"	ft	line:85
traverseIntMap	src/Data/IntMap/Lens.hs	/^traverseIntMap :: IndexedTraversal Int (IntMap v) (IntMap v') v v'$/;"	ft	line:44
traverseLast	src/Data/List/Lens.hs	/^traverseLast :: SimpleIndexedTraversal Int [a] a$/;"	ft	line:131
traverseLast	src/Data/Sequence/Lens.hs	/^traverseLast :: SimpleIndexedTraversal Int (Seq a) a$/;"	ft	line:78
traverseLeft	src/Data/Either/Lens.hs	/^traverseLeft :: Traversal (Either a c) (Either b c) a b$/;"	ft	line:24
traverseList	src/Data/List/Lens.hs	/^traverseList :: IndexedTraversal Int [a] [b] a b$/;"	ft	line:89
traverseMap	src/Data/Map/Lens.hs	/^traverseMap :: IndexedTraversal k (Map k v) (Map k v') v v'$/;"	ft	line:48
traverseNothing	src/Control/Lens/Traversal.hs	/^traverseNothing :: Traversal a a c d$/;"	ft	line:316
traverseOf	src/Control/Lens/Traversal.hs	/^traverseOf :: LensLike f a b c d -> (c -> f d) -> a -> f b$/;"	ft	line:115
traverseOf_	src/Control/Lens/Fold.hs	/^traverseOf_ :: Functor f => Getting (Traversed f) a c -> (c -> f e) -> a -> f ()$/;"	ft	line:406
traverseRight	src/Data/Either/Lens.hs	/^traverseRight :: Traversal (Either c a) (Either c b) a b$/;"	ft	line:37
traverseSeq	src/Data/Sequence/Lens.hs	/^traverseSeq :: IndexedTraversal Int (Seq a) (Seq b) a b$/;"	ft	line:57
traverseSlice	src/Data/Sequence/Lens.hs	/^traverseSlice :: Int -> Int -> SimpleIndexedTraversal Int (Seq a) a$/;"	ft	line:104
traverseTail	src/Data/List/Lens.hs	/^traverseTail :: SimpleIndexedTraversal Int [a] a$/;"	ft	line:117
traverseTail	src/Data/Sequence/Lens.hs	/^traverseTail :: SimpleIndexedTraversal Int (Seq a) a$/;"	ft	line:71
traverseTo	src/Data/Sequence/Lens.hs	/^traverseTo :: Int -> SimpleIndexedTraversal Int (Seq a) a$/;"	ft	line:92
traverseWithRep	src/Control/Lens/Representable.hs	/^traverseWithRep :: (Representable f, Traversable f, Applicative g)$/;"	ft	line:239
traverseWithRep_	src/Control/Lens/Representable.hs	/^traverseWithRep_ :: (Representable f, Foldable f, Applicative g)$/;"	ft	line:246
typeVars	src/Language/Haskell/TH/Lens.hs	/^typeVars :: HasTypeVars t => Simple Traversal t Name$/;"	ft	line:89
typeVarsEx	src/Language/Haskell/TH/Lens.hs	/^  typeVarsEx :: Set Name -> Simple Traversal t Name$/;"	ft	line:61
unfocusing	src/Control/Lens/Internal.hs	/^newtype Focusing m c a = Focusing { unfocusing :: m (c, a) }$/;"	c_a	line:44
unfolded	src/Control/Lens/Fold.hs	/^unfolded :: (b -> Maybe (a, b)) -> Fold b a$/;"	ft	line:158
untainted	src/Control/Lens/Setter.hs	/^  untainted :: f a -> a$/;"	ft	line:125
unviewl	src/Data/Sequence/Lens.hs	/^unviewl :: ViewL a -> Seq a$/;"	ft	line:41
unviewr	src/Data/Sequence/Lens.hs	/^unviewr :: ViewR a -> Seq a$/;"	ft	line:53
use	src/Control/Lens/Getter.hs	/^use :: MonadState a m => Getting c a c -> m c$/;"	ft	line:288
uses	src/Control/Lens/Getter.hs	/^uses :: MonadState a m => Getting e a c -> (c -> e) -> m e$/;"	ft	line:303
value	src/Data/Pair/Lens.hs	/^value :: (k -> Bool) -> SimpleIndexedTraversal k (k, v) v$/;"	ft	line:30
via	src/Control/Lens/Iso.hs	/^via :: Isomorphic k => Isomorphism a b -> k a b$/;"	ft	line:102
view	src/Control/Lens/Getter.hs	/^view :: Getting c a c -> a -> c$/;"	ft	line:172
viewL	src/Data/Sequence/Lens.hs	/^viewL :: Iso (Seq a) (Seq b) (ViewL a) (ViewL b)$/;"	ft	line:38
viewR	src/Data/Sequence/Lens.hs	/^viewR :: Iso (Seq a) (Seq b) (ViewR a) (ViewR b)$/;"	ft	line:49
views	src/Control/Lens/Getter.hs	/^views :: Getting m a c -> (c -> m) -> a -> m$/;"	ft	line:192
walk	src/Control/Lens/Representable.hs	/^newtype Path f = Path { walk :: Rep f }$/;"	c_a	line:211
withIndex	src/Control/Lens/Indexed.hs	/^newtype Index i a b = Index { withIndex :: (i -> a) -> b }$/;"	c_a	line:47
{	src/Control/Lens/IndexedLens.hs	/^{-# INLINE (%%@=) #-}$/;"	fi	line:107
{	src/Control/Lens/IndexedSetter.hs	/^{-# INLINE (%@=) #-}$/;"	fi	line:91
{	src/Control/Lens/Setter.hs	/^{-# INLINE (.=) #-}$/;"	fi	line:498
{	src/Control/Lens/Type.hs	/^{-# INLINE (%%=) #-}$/;"	fi	line:251
{	src/Data/Bits/Lens.hs	/^{-# INLINE (&=) #-}$/;"	fi	line:47
|=	src/Data/Bits/Lens.hs	/^(|=) :: (MonadState a m, Bits b) => Simple Setting a b -> b -> m ()$/;"	ft	line:50
||=	src/Control/Lens/Setter.hs	/^(||=) :: MonadState a m => SimpleSetting a Bool -> Bool -> m ()$/;"	ft	line:627
||~	src/Control/Lens/Setter.hs	/^(||~):: Setting a b Bool Bool -> Bool -> a -> b$/;"	ft	line:441
|~	src/Data/Bits/Lens.hs	/^(|~):: Bits c => Setting a b c c -> c -> a -> b$/;"	ft	line:32
